////////////////////////////////////////////////////////////////////////////
//	Created		: 26.11.2023
//	Author		: Deathman
//  Nocturning studio for NS Project X
////////////////////////////////////////////////////////////////////////////
#include "common.h"
#include "gbuffer.h"
#include "accumulation_helper.h"
#include "ambient_light.h"
#include "reflection.h"
#include "reflections_ssr.h"
#include "BRDF.h"
////////////////////////////////////////////////////////////////////////////
float4 main (float2 TexCoords: TEXCOORD0): COLOR
{
    GBuffer GBuffer = UnpackGBuffer(TexCoords);
    LightingData Light = UnpackLightingAccumulator(TexCoords);

    float NdotV = max(dot(GBuffer.Normal, -normalize(GBuffer.Position)), 0.0);
    float3 WorldSpaceNormal = mul(m_v2w, GBuffer.Normal);
    float3 v2pointL = normalize(GBuffer.Position);
    float3 v2point = mul(m_v2w, v2pointL);
    float WorldSpaceNdotV = max(dot(WorldSpaceNormal, -v2point), 0.0);
    float3 vreflect = reflect(v2point, WorldSpaceNormal);

    // True remapping
    float3 vreflectabs = abs(vreflect);
    float vreflectmax = max(vreflectabs.x, max(vreflectabs.y, vreflectabs.z));
    vreflect /= vreflectmax;
    if (vreflect.y < 0.99f)
        vreflect.y = vreflect.y * 2.0f - 1.0f;

    float IOR = 1.5f;
    float3 F0 = pow(IOR - 1.0f, 2.0f) / pow(IOR + 1.0f, 2.0f);
    F0 = lerp(F0, GBuffer.Albedo, GBuffer.Metallness);
    float3 F = fresnelSchlickRoughness(F0, NdotV, GBuffer.Roughness);
    float3 kD = (1.0f - F) * (1.0 - GBuffer.Metallness);
    float MipLevel = getMipLevelFromRoughness(GBuffer.Roughness, 8.0f);

    float BakedAO = (GBuffer.BakedAO + 1.0f) * 0.5f;
    float RealTimeAO = tex2Dlod0(s_ao, TexCoords).r;

    float3 IrradianceActualHour = texCUBElod(env_s0, float4(WorldSpaceNormal, max(3.0f, MipLevel)));
    float3 IrradianceNextHour = texCUBElod(env_s1, float4(WorldSpaceNormal, max(3.0f, MipLevel)));
    float3 Irradiance = env_color.rgb * lerp(IrradianceActualHour, IrradianceNextHour, env_color.w);
    Irradiance = lerp(Irradiance, fog_color.rgb, fog_sky_influence);
    Irradiance = CalcTonemap (Irradiance);

    float3 ReflectedSkyActualHour = texCUBElod(sky_s0, float4(vreflect, MipLevel));
    float3 ReflectedSkyNextHour = texCUBElod(sky_s1, float4(vreflect, MipLevel));
    float3 ReflectedSky = env_color.rgb * lerp(ReflectedSkyActualHour, ReflectedSkyNextHour, env_color.w);
    ReflectedSky = lerp(ReflectedSky, fog_color.rgb, fog_sky_influence);
    ReflectedSky = CalcTonemap (ReflectedSky);

#ifdef USE_BRDF_LUT
    float2 envBRDF = getBRDFIntegrationMap(float2(WorldSpaceNdotV, GBuffer.Roughness)).rg;
    float3 specularIBL = ReflectedSky * (F * envBRDF.x + envBRDF.y);
#else
    float3 specularIBL = ReflectedSky * F;
#endif

    float3 DirectLighting = kD * GBuffer.Albedo * Light.Diffuse + Light.Specular;

    float3 IndirectDiffuse = kD * GBuffer.Albedo * Irradiance * (GBuffer.AO + L_ambient.rgb) * BakedAO * RealTimeAO;
    
    float3 IndirectSpecular = specularIBL * (GBuffer.AO + L_ambient.rgb);

    float3 IndirectLighting = IndirectDiffuse + IndirectSpecular;

    float3 SceneColor = DirectLighting + IndirectLighting;
    
    float Fog = CalcFogness (GBuffer.Position);
    SceneColor = lerp (SceneColor, fog_params.rgb, Fog);
    float Opacity = pow (Fog, 2.2f);

    SceneColor = CalcTonemap (SceneColor);
    
	// SSR from DWM
	{
		// float4 reflections = calc_ssr(TexCoords, GBuffer.Position, normalize(mul((float3x3)m_V, float3(0,1,0))), 0);
		float4 reflections = calc_ssr(TexCoords, GBuffer.Position, GetNormal(TexCoords), 0);
		SceneColor = lerp(SceneColor, reflections.rgb, reflections.a) * F;
	}
	
    return float4 (SceneColor, Opacity);
}
////////////////////////////////////////////////////////////////////////////
