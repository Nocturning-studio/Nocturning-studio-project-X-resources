//////////////////////////////////////////////////////////////////////////////////////////
#include "common.h"
//////////////////////////////////////////////////////////////////////////////////////////
struct v2p
{
	float4 color: COLOR0; // multiplier, color.w = noise_amount
	float4 gray: COLOR1; // (.3,.3,.3.,amount)
 	float2 tc0: TEXCOORD0; // base1 (duality)
 	float2 tc1: TEXCOORD1; // base2 (duality)
 	float2 tc2: TEXCOORD2; // base  (noise)
};
//////////////////////////////////////////////////////////////////////////////////////////
uniform_sampler2D(s_base0, smp_rtlinear);
uniform_sampler2D(s_base1, smp_rtlinear);
uniform_sampler2D(s_noise, smp_rtlinear);
uniform float4 c_brightness;
//////////////////////////////////////////////////////////////////////////////////////////
// Pixel
float4 main (v2p I): COLOR
{
	float3 t_0 = tex2Dlod0 (s_base0, I.tc0);
	float3 t_1 = tex2Dlod0 (s_base1, I.tc1);
	float3 image = (t_0 + t_1) * .5;
    
#ifdef USE_CHROMATIC_ABBERATION
    image.rgb = ChromaticAberration (s_base, image.rgb, (I.tc0 + I.tc1) * 0.5f);
#endif
    
    float gray = dot (image, I.gray);
    image = lerp (gray, image, I.gray.w);

	float4 t_noise = tex2Dlod0 (s_noise, I.tc2);
	float3 noised = image * t_noise * 2;
    image = lerp (noised, image, I.color.w);
    
    image = (image * I.color + c_brightness) * 2;
    
#ifdef VIGNETTE_MODE
#if VIGNETTE_MODE == 1
    float VignettePower = 0.5f;  
#elif VIGNETTE_MODE == 2
    float VignettePower = vignette_power;
#endif
    float Vignette = tex2D (s_vignette, I.tc1).r;
    image *= Vignette + (1.0f - Vignette) * (1.0f - VignettePower);
#endif    

#ifdef USE_SEPIA
    image *= sepia_params.rgb + (1.0f - sepia_params.rgb) * (1.0f - sepia_params.a);
#endif
    
    return float4 (image, 1);
}
//////////////////////////////////////////////////////////////////////////////////////////
