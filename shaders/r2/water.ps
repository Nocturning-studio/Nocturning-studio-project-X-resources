#include "common.h"
#include "gbuffer.h"
#include "shared\fog.h"
#include "hdr.h"

struct vf
{
        float4 hpos: POSITION;
		float2 tbase: TEXCOORD0; // base
        float2 tnorm0: TEXCOORD1; // nm0
        float2 tnorm1: TEXCOORD2; // nm1
        float3 M1: TEXCOORD3;
        float3 M2: TEXCOORD4;
        float3 M3: TEXCOORD5;
        float3 v2point: TEXCOORD6;
		float4 tctexgen: TEXCOORD7;
		float3 position: TEXCOORD8;
        float4 c0: COLOR0;
};

struct PixelShaderOutputStruct
{
	float4 Generic_0: COLOR0;
	float4 Position: COLOR1;
};

uniform sampler2D s_nmap;
uniform samplerCUBE s_env0;
uniform samplerCUBE s_env1;
uniform sampler2D s_leaves;

#if defined(USE_SOFT_WATER) && defined(NEED_SOFT_WATER)
float3	water_intensity;
#endif	//	defined(USE_SOFT_WATER) && defined(NEED_SOFT_WATER)

////////////////////////////////////////////////////////////////////////////////
PixelShaderOutputStruct main (vf I)
{
	float4 base = tex2D (s_base, I.tbase);
	float3 n0 = tex2D (s_nmap, I.tnorm0);
	float3 n1 = tex2D (s_nmap, I.tnorm1);
	float3 Navg = n0 + n1 - 1;

	float3 Nw = mul (float3x3 (I.M1, I.M2, I.M3), Navg);
    Nw = normalize (Nw);
	float3 v2point = normalize (I.v2point);
	float3 vreflect = reflect (v2point, Nw);
#ifndef USE_SOFT_WATER // fake remapping
    vreflect.y = vreflect.y * 2 - 1;
#else	//	true remapping. Slow.
	float3 vreflectabs = abs(vreflect);
	float vreflectmax = max( vreflectabs.x, max(vreflectabs.y, vreflectabs.z));
	vreflect /= vreflectmax;
	if (vreflect.y<0.99)
		vreflect.y = vreflect.y*2-1;
#endif

	float3 env0 = texCUBE (s_env0, vreflect);
	float3 env1 = texCUBE (s_env1, vreflect);
	float3 env = lerp (env0, env1, L_ambient.w);
    env *= env * 2;
    env = lerp (env, fog_params.rgb, fog_sky_influence);

    float fresnel = saturate (dot (vreflect, v2point));
    float power = pow (fresnel, 9);
    float amount = 0.15h + 0.25h * power; // 1=full env, 0=no env
	
	float3 c_reflection = env * amount;
	float3 final = lerp (c_reflection, base.rgb, base.a);

    final *= I.c0 * 2;
	
    float Opacity = 1.0h;
	
#ifdef	NEED_SOFT_WATER
	float	alpha	= 0.75h+0.25h*power;                        // 1=full env, 0=no env

	//	Igor: additional depth test
	float Depth = GetPosition(I.tctexgen.xy/I.tctexgen.w).z;
	float waterDepth = Depth-I.tctexgen.z;

	//	water fog
	float  fog_exp_intens = -4.0h;
	float fog	= 1-exp(fog_exp_intens*waterDepth);
	float3 Fc  	= float3( 0.1h, 0.1h, 0.1h) * water_intensity.r;
	final 		= lerp (Fc, final, alpha);

	alpha 		= min(alpha, saturate(waterDepth));

	alpha 		= max (fog, alpha);

	//	Leaves
	float4	leaves	= tex2D(s_leaves, I.tbase);
			leaves.rgb *= water_intensity.r;
	float	calc_cos = dot ( I.M3,  v2point);
	float	calc_depth = saturate(waterDepth*calc_cos);
	float	fLeavesFactor = smoothstep(0.025, 0.05, calc_depth );
			fLeavesFactor *= smoothstep(0.1, 0.075, calc_depth );
	final		= lerp(final, leaves, leaves.a*fLeavesFactor);
	alpha		= lerp(alpha, leaves.a, leaves.a*fLeavesFactor);
	Opacity = alpha;
#endif	//	NEED_SOFT_WATER
	
	// Deathman - считаем туман второй раз, но теперь специально для этого конкретного объекта
    float Fog = CalcFogness (I.position);
    final.rgb = lerp (final.rgb, fog_params.rgb, Fog);
    Opacity *= 1.0h - pow (Fog, 2.2h);
	
    final = Calc_hdr (final);
	
    PixelShaderOutputStruct Output;
    Output.Generic_0 = float4 (final.rgb, Opacity);
    Output.Position = float4 (I.position, 1.0);
    return Output;
}
