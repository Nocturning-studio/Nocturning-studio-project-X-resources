//////////////////////////////////////////////////////////////////////////////////////////
#include "common.h"
#include <chromatic_abberations.h>
//////////////////////////////////////////////////////////////////////////////////////////
struct Interpolators
{
    float4 HomogeniousPosition: SV_Position;
    float2 DualityTexCoords0: TEXCOORD0;
    float2 DualityTexCoords1: TEXCOORD1;
    float2 NoiseTexCoords: TEXCOORD2;
    float4 Color: COLOR0;
    float4 Gray: COLOR1;
};
//////////////////////////////////////////////////////////////////////////////////////////
texture2D t_noise;
texture2D t_depth;
//////////////////////////////////////////////////////////////////////////////////////////
uniform float4 c_brightness;
uniform float3 hdr_params;
//////////////////////////////////////////////////////////////////////////////////////////
float GetDepth(float2 TexCoords)
{
	float DepthBuffer = t_depth.Sample(smp_nofilter, TexCoords).a;
    return LinearizeDepth (DepthBuffer);
}
//////////////////////////////////////////////////////////////////////////////////////////
float3 CalcDepthOfField(float3 ImageColor, float2 TexCoords)
{
    float BlurPower = DOFFactor (GetDepth (TexCoords));
    if (BlurPower == 0.0f)
    {
        return ImageColor;
    }
    else
    {
        float2 RaySize = screen_res.zw;
        float3 SummaryImageColor = 0;
        float Contribution = 0.0f;
	
        for (int i = 0; i < 16; i++)
        {
            float2 SampleCoords = TexCoords + poissonDisk_16[i] * RaySize * 2.5f;

            float3 SampleColor = t_base.Sample (smp_nofilter, SampleCoords.xy);

            float SampleContribution = DOFFactor (GetDepth (SampleCoords));

            SummaryImageColor += SampleColor * SampleContribution;

            Contribution += SampleContribution;
        }
	
        float3 BlurredImageColor = (SummaryImageColor / Contribution) * BlurPower;
        float3 UnblurredImageColor = ImageColor * (1.0f - BlurPower);

        return BlurredImageColor + UnblurredImageColor;
    }
}
//////////////////////////////////////////////////////////////////////////////////////////
// Pixel
float4 main (Interpolators Input): SV_Target
{
#ifdef USE_DISTORTION
    float2 Distort = t_distort.Sample (smp_linear, TexCoord);
    float2 SampleOffset = (distort.xy - 0.5f) * def_distort;
#else
    float2 SampleOffset = float2 (0.0f, 0.0f);
#endif
    
    float3 ImageColor0 = t_base.Sample (smp_linear, Input.DualityTexCoords0 + SampleOffset);
    float3 ImageColor1 = t_base.Sample (smp_linear, Input.DualityTexCoords1 + SampleOffset);
    float3 ImageColor = (ImageColor0 + ImageColor1) * 0.5f;
    
#ifdef USE_CHROMATIC_ABBERATION
    ImageColor.rgb = ChromaticAberration (t_base, ImageColor.rgb, (Input.DualityTexCoords0 + Input.DualityTexCoords1) * 0.5f);
#endif 

#ifdef VIGNETTE_MODE
#if VIGNETTE_MODE == 1
    float VignettePower = 0.5f;  
#elif VIGNETTE_MODE == 2
    float VignettePower = vignette_power;
#endif
    float Vignette = t_vignette.Sample(smp_linear, Input.DualityTexCoords1).r;
    ImageColor *= Vignette + (1.0f - Vignette) * (1.0f - VignettePower);
#endif    

#ifdef USE_SEPIA
    ImageColor *= sepia_params.rgb + (1.0f - sepia_params.rgb) * (1.0f - sepia_params.a);
#endif
    
    float gray = dot (ImageColor, Input.Gray.rgb);
    ImageColor = lerp (gray, ImageColor, Input.Gray.w);

    float4 NoiseColor = t_noise.Sample(smp_nofilter, Input.NoiseTexCoords);
    float3 NoisedImageColor = ImageColor * NoiseColor * 2.0f;
    ImageColor = lerp (NoisedImageColor, ImageColor, Input.Color.w);
    
    ImageColor = (ImageColor * Input.Color.rgb + c_brightness) * 2.0f;
    
    return float4 (ImageColor, 1.0f);
}
//////////////////////////////////////////////////////////////////////////////////////////
