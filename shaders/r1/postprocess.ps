//////////////////////////////////////////////////////////////////////////////////////////
#include "common.h"
//////////////////////////////////////////////////////////////////////////////////////////
struct v2p
{
    float2 tc0: TEXCOORD0; // base1 (duality)
    float2 tc1: TEXCOORD1; // base2 (duality)
    float2 tc2: TEXCOORD2; // base  (noise)
    float4 color: COLOR0; // multiplier, color.w = noise_amount
    float4 gray: COLOR1; // (.3,.3,.3.,amount)
};
//////////////////////////////////////////////////////////////////////////////////////////
uniform_sampler2D(s_noise, smp_nofilter);
uniform_sampler2D(s_distort, smp_nofilter);
uniform_sampler2D(s_vignette, smp_nofilter);
uniform_sampler2D(s_depth, smp_nofilter);
//////////////////////////////////////////////////////////////////////////////////////////
uniform float4 c_brightness;
uniform float3 hdr_params;
//////////////////////////////////////////////////////////////////////////////////////////
float GetDepth(float2 TexCoords)
{
	float DepthBuffer = tex2D(s_depth, TexCoords).a;
    return LinearizeDepth (DepthBuffer);
}
//////////////////////////////////////////////////////////////////////////////////////////
float3 CalcDepthOfField(float3 ImageColor, float2 TexCoords)
{
    float BlurPower = DOFFactor (GetDepth (TexCoords));
    if (BlurPower == 0.0f)
    {
        return ImageColor;
    }
    else
    {
        float2 RaySize = screen_res.zw;
        float3 SummaryImageColor = 0;
        float Contribution = 0.0f;
	
        for (int i = 0; i < 16; i++)
        {
            float2 SampleCoords = TexCoords + poissonDisk_16[i] * RaySize * 2.5f;

            float3 SampleColor = tex2D(s_base, SampleCoords.xy);

            float SampleContribution = DOFFactor (GetDepth (SampleCoords));

            SummaryImageColor += SampleColor * SampleContribution;

            Contribution += SampleContribution;
        }
	
        float3 BlurredImageColor = (SummaryImageColor / Contribution) * BlurPower;
        float3 UnblurredImageColor = ImageColor * (1.0f - BlurPower);

        return BlurredImageColor + UnblurredImageColor;
    }
}
//////////////////////////////////////////////////////////////////////////////////////////
// Pixel
float4 main (v2p I): SV_Target
{
#ifdef USE_DISTORTION
    float4 distort = tex2D(s_distort, I.tc0);
	float2 offset = (distort.xy - 0.5f) * def_distort;
#else
    float2 offset = float2 (0.0f, 0.0f);
#endif
    
    float3 t_0 = tex2D(s_base, I.tc0 + offset);
    float3 t_1 = tex2D(s_base, I.tc1 + offset);
    float3 image = (t_0 + t_1) * 0.5f;
    
#ifdef USE_CHROMATIC_ABBERATION
    image.rgb = ChromaticAberration (s_base, image.rgb, (I.tc0 + I.tc1) * 0.5f);
#endif
    
#ifdef USE_HDR
    image = pow(image, hdr_params.y);
    image *= hdr_params.z;
    const float fWhiteIntensity = hdr_params.x;
    const float fWhiteIntensitySQR = fWhiteIntensity * fWhiteIntensity;

    image = float3 (((image * (1.0f + image / fWhiteIntensitySQR)) / (image + 1.0f)));
#endif    

#ifdef VIGNETTE_MODE
#if VIGNETTE_MODE == 1
    float VignettePower = 0.5f;  
#elif VIGNETTE_MODE == 2
    float VignettePower = vignette_power;
#endif
    float Vignette = tex2D (s_vignette, I.tc1).r;
    image *= Vignette + (1.0f - Vignette) * (1.0f - VignettePower);
#endif    

#ifdef USE_SEPIA
    image *= sepia_params.rgb + (1.0f - sepia_params.rgb) * (1.0f - sepia_params.a);
#endif
    
    float gray = dot (image, I.gray);
    image = lerp (gray, image, I.gray.w);

    float4 t_noise = tex2D (s_noise, I.tc2);
    float3 noised = image * t_noise * 2.0f;
    image = lerp (noised, image, I.color.w);
    
    image = (image * I.color + c_brightness) * 2.0f;
    
    return float4 (image, 1.0f);
}
//////////////////////////////////////////////////////////////////////////////////////////
