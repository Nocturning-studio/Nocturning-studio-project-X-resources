//////////////////////////////////////////////////////////////////////////////////////////
//	Created		: 14.01.2024
//	Author		: Mihan323
//	NSProjectX Nocturning Studio - 2024
//////////////////////////////////////////////////////////////////////////////////////////
#include "common.h"
#include "gbuffer.h"
//////////////////////////////////////////////////////////////////////////////////////////
// Options
#define POWER  vector(2.2)
#define	RADIUS vector(2)
#define BIAS vector(0.007)
#define SAMPLES 4
#define STEPS 2
#define RENDER_DISTANCE 75.0h
//////////////////////////////////////////////////////////////////////////////////////////
vector4 main (vector2 TexCoords: TEXCOORD0, vector2 Position2D: VPOS): COLOR
{
    vector3 Position = GetPosition (TexCoords);
    
    if (Position.z > RENDER_DISTANCE)
    {
        return vector4 (1.0h, 1.0h, 1.0h, 1.0h);
    }
    else
    {
        vector3 Normal = tex2D (s_gbuffer_normal, TexCoords);
        
	    // float radiusPixels = (Radius * screen_res.y * 0.5) / (pos.z * tan(radians(Fov * 0.5)));
        float radiusPixels = (RADIUS * screen_res.y * 0.5) / (Position.z * -pos_decompression_params.y);

	    // Early exit if the projected radius is smaller than 1 full-res pixel
        if (radiusPixels < 1.0)
        {
            return vector4 (1.0h, 1.0h, 1.0h, 1.0h);
        }
        else
        {
            float occ = 0;

            // RotationCosSin is (cos(alpha),sin(alpha)) where alpha is the rotation angle
	        // A 2D rotation matrix is applied (see https://en.wikipedia.org/wiki/Rotation_matrix)
            float c, s;
            sincos (PI, c, s);
            float2x2 rot = float2x2 (c, -s, s, c);
            
            int2 pos2d = Position2D; //TexCoords * screen_res.xy + 0.5;
            float jitter = (pos2d.y % 4) * 0.25 + (pos2d.x % 4) * 0.0625 + 0.0625;
            float2 dir;
            sincos (5.0 * PI * jitter, dir.y, dir.x);
            dir = lerp (dir, jitter, 0.5);
	
            Position += Normal * BIAS;
	
		    // Divide by Steps+1 so that the farthest samples are not fully attenuated
            float stepSizePixels = (radiusPixels * 0.25) / (STEPS + 1);
		
            for (int i = 0; i < SAMPLES; ++i)
            {
                float negInvR2 = -1.0 / pow (radiusPixels, 2.0h);
                float rayPixels = 0.5 * stepSizePixels + 1.0;

                float dirSum = 0;
		
                dir = mul (dir, rot);
                
                for (int j = 0; j < STEPS; ++j)
                {
                    float2 tcDelta = round (rayPixels * dir) * screen_res.zw;
                    float2 tcHit = TexCoords + tcDelta;
			
                    rayPixels += stepSizePixels;

                    if ((tcHit.x <= 1.0 && tcHit.y <= 1.0 && tcHit.x >= 0.0 && tcHit.y >= 0.0))
                    {
                        float3 posHit = GetPosition (tcHit);
                        posHit.z += BIAS;
			
					    // pos    = view-space position at the kernel center
					    // norm   = view-space normal at the kernel center
					    // posHit = view-space position of the current sample
                        float3 V = Position - posHit;
                        float VdotV = dot (V, V);
                        float NdotV = dot (Normal, -V) * rsqrt (VdotV);

					    // Use saturate(x) instead of max(x,0.f) because that is faster
                        float falloff = saturate (VdotV * negInvR2 + 1.0);
                        float occluder = saturate (NdotV);
                        
                        dirSum += occluder * falloff;
                    }
                }
		
                dirSum = dirSum / STEPS;
	
                occ += dirSum;
            }

            occ = saturate (pow (1 - occ / SAMPLES, POWER));

            // Create smooth render distance border
            vector FarFadingFactor = smoothstep (RENDER_DISTANCE * 0.75h, RENDER_DISTANCE, length (Position));
            occ = lerp (1.0h, occ, 1.0h - FarFadingFactor);
            
            return occ.xxxx;
        }
    }
}