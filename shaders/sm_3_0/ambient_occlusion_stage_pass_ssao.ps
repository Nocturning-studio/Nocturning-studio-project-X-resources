////////////////////////////////////////////////////////////////////////////
//	Modyfied	: 15.11.2022 - 15.01.2024
//	By			: Deathman, LVutner, Mihan323
//	Base method from : S.T.A.L.K.E.R: Anarchy Cell E3 Demo 19.08.2007 (Build 3120)
////////////////////////////////////////////////////////////////////////////
#include "common.h"
#include "gbuffer.h"
////////////////////////////////////////////////////////////////////////////
// Options
////////////////////////////////////////////////////////////////////////////
#define KERNEL_SIZE float(200)
#define POWER float(2.2)
////////////////////////////////////////////////////////////////////////////
// Presets
#if AO_QUALITY == UNDEFINED_QUALITY
#define SAMPLES 3
#define RENDER_DISTANCE 25.0h
#elif AO_QUALITY == LOW_QUALITY
#define SAMPLES 3
#define RENDER_DISTANCE 25.0f
#elif AO_QUALITY == MIDDLE_QUALITY
#define SAMPLES 3
#define RENDER_DISTANCE 50.0h
#elif AO_QUALITY == HIGHT_QUALITY
#define SAMPLES 4
#define RENDER_DISTANCE 75.0h
#elif AO_QUALITY == ULTRA_QUALITY
#define SAMPLES 4
#define RENDER_DISTANCE 100.0h
#endif
////////////////////////////////////////////////////////////////////////////
float2 CalcDirection (float2 TexCoords, float2 Position2D)
{
    int2 pos2d = Position2D; //TexCoords * screen_res.xy + 0.5;
    float jitter = (pos2d.y % 4) * 0.25 + (pos2d.x % 4) * 0.0625 + 0.0625;
    float2 dir;
    sincos (5.0 * PI * jitter, dir.y, dir.x);
    dir = lerp (dir, jitter, 0.5);
    return dir;
}
////////////////////////////////////////////////////////////////////////////
float4 main (float2 TexCoords: TEXCOORD0, float2 Position2D: VPOS): COLOR
{
    if (GetPosition (TexCoords).z > RENDER_DISTANCE)
    {
        return float4 (1.0h, 1.0h, 1.0h, 1.0h);
    }
    else
    {
	    // Position and normal for pixel, where we should get occlusion
	    float3 CenterRayNormalData = tex2D (s_gbuffer_normal, TexCoords);
	    float3 CenterRayPositionData = GetPosition (TexCoords);

	    // Create pixel scale
	    float2 RaySize = float2 (0.5h / screen_res.xy) * KERNEL_SIZE / max (CenterRayPositionData.z, 1.0h);

	    // Values, wich we will use outside the cycle
        float Occlusion = 0.0h;
        float DirectionsCount = 0.0h;

        // RotationCosSin is (cos(alpha),sin(alpha)) where alpha is the rotation angle
	    // A 2D rotation matrix is applied (see https://en.wikipedia.org/wiki/Rotation_matrix)
        float c, s;
        sincos (PI, c, s);
        float2x2 rot = float2x2 (c, -s, s, c);
        
        float2 Jitter = CalcDirection (TexCoords, Position2D);
        
        for (int i = 0; i < SAMPLES; i++)
        {
		    float2 SearchRayCoord = TexCoords + mul (Jitter, rot) * RaySize;

			float3 SearchRayPositionData = GetPosition (SearchRayCoord);

			float3 SearchRayDirection = SearchRayPositionData - CenterRayPositionData;
                
            float SearchRayIntersectDistance = length (SearchRayDirection);
                
            SearchRayDirection = normalize (SearchRayDirection);
                
            float RayInfluence = dot (SearchRayDirection, CenterRayNormalData);

            float OcclusionFactor = saturate (SearchRayIntersectDistance);
                
            Occlusion += (RayInfluence + 0.01f) * lerp (1.0h, OcclusionFactor, RayInfluence) / (OcclusionFactor + 0.1f);
                
            DirectionsCount += (RayInfluence + 0.01f) / (OcclusionFactor + 0.1f);
        }
        
        Occlusion /= DirectionsCount;

        float FarFadingFactor = smoothstep (RENDER_DISTANCE * 0.75h, RENDER_DISTANCE, length (CenterRayPositionData));
        Occlusion = lerp (1.0h, Occlusion, 1.0h - FarFadingFactor);

        return pow (Occlusion, POWER).xxxx;
    }
}
////////////////////////////////////////////////////////////////////////////
